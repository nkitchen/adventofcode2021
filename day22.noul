#!/usr/bin/env noulith

DEBUG := 0;
TEST := 0;
import "aoc.noul";

reboot_steps := \filename -> (
    steps := [];
    for (line <- read_file(filename).lines) (
        sense, coords := line.words;
        xmin, xmax, ymin, ymax, zmin, zmax := coords.ints;
        lo := [xmin, ymin, zmin];
        hi := [xmax, ymax, zmax];
        steps append= [sense, [lo, hi]];
    );
    steps
);

csize := \c -> (
    lo, hi := c;
    d := (hi zip - zip lo) zip (+ 1);
    d zip (max 0) fold *
);

cubisect := \c, d -> (
    [c[0] zip max zip d[0],
     c[1] zip min zip d[1]]
);

# A list of disjoint cuboids covering the same points as c.
# x is a sub-cuboid of c.
sunder := \x, c -> (
    if (x == c) (
        return [c];
    );
    assert ((x cubisect c) == x);

    # c need not be broken down into the smallest possible sub-cuboids.
    # As a 2-D analog, instead of doing this:
    #
    # +-------+     +--+-+--+
    # |       |     |  | |  |
    # |  +-+  +     +--+-+--+
    # |  | |  | ==> |  | |  |
    # +  +-+  |     +--+-+--+
    # |       |     |  | |  |
    # +--+----+     +--+-+--+
    #
    # we can do this:
    #
    # +-------+     +--+-+--+
    # |       |     |  | |  |
    # |  +-+  +     +  +-+  +
    # |  | |  | ==> |  | |  |
    # +  +-+  |     +  +-+  +
    # |       |     |  | |  |
    # +--+----+     +--+-+--+
    #
    # That is, instead of dividing the cuboid into (up to) 27 different regions,
    # in one dimension we can keep a single cuboid below and above x,
    # and the same in the next dimension in the slice around x,
    # with a total of 7 possible cuboids, including x.

    # Which order of dimensions is best?  Let's try to minimize the number of
    # intersections between cuboids by avoiding the largest sub-cuboids --
    # that is, slice the longest span first.
    clo, chi := c;
    k := len(clo);
    spans := [];
    for (i <- 0 til k) (
        spans append= [chi[i] - clo[i] + 1, i];
    );
    spans = spans.sort.reverse;

    xlo, xhi := x;

    ds := [];
    c' := c;
    for (span <- spans) (
        i := span[1];

        dlo, dhi := c';
        dhi[i] = xlo[i] - 1;
        d := [dlo, dhi];
        if (d.csize > 0)
            ds append= d;
            
        dlo, dhi = c';
        dlo[i] = xhi[i] + 1;
        d = [dlo, dhi];
        if (d.csize > 0)
            ds append= d;

        c'[0][i] = xlo[i];
        c'[1][i] = xhi[i];
    );
    ds append= x;

    n' := ds map csize fold +;
    assert (n' == c.csize);
    ds
);

reboot_cubes := \steps -> (
    # Thanks to https://github.com/Dullstar/Advent_Of_Code/blob/main/python/year2021/day22.py
    n := 0;
    cs := [];
    for ([sense, c] <- steps.reverse) (
        if (sense == "on") (
            steps' := [];
            for (c' <- cs) (
                x := c cubisect c';
                if (x.csize > 0) (
                    steps' append= ["on", x];
                );
            );
            n += c.csize - reboot_cubes(steps');
        );
        cs append= c;
    );
    n
);

init_cubes := \filename -> (
    steps := reboot_steps(filename);
    init_region := [(-50) .* 3, 50 .* 3];
    steps' := steps map (\[sense, c] -> [sense, c cubisect init_region]);
    reboot_cubes(steps')
);

solve := \ -> (
    f := "in22.txt";
    n := init_cubes(f);
    print(n);
    steps := reboot_steps(f);
    n = reboot_cubes(steps);
    print(n);
);

if (TEST) (
    import "test22.noul";
    test();
) else (
    solve();
);

# 6s
